
const int N=1e5+10,M=30;
int g[N][M],f[N],a='a';
int nodes=0;
bool pattern[N];
int out[N];
map<int,int> inde;

void inst(string s,int ind){
	int node=0;
	for(auto x : s){
		int loc=x-a;
		if(g[node][loc]!=-1) node=g[node][loc];
		else node=g[node][loc]=++nodes;
	}
	pattern[node]=true;
	inde[node]=ind;
}

void build(void){
	queue<int> q;
	rep(i,0,M) if(g[0][i]){ q.push(g[0][i]); f[i]=0; };
	while(!q.empty()){
		auto r=q.front();q.pop();
		rep(i,0,M){
			if(g[r][i]==-1) continue;
			auto u=g[r][i];
			q.push(u);
			auto v=f[r];
			while(g[v][i]==-1) v=f[v];
			f[u]=g[v][i];
			// out(u):=out(u) U out(f(u))
			// current node = u ---- suffix link node = f[u]
			if(pattern[f[u]]) out[u]=f[u];
			else out[u]=out[f[u]];
		}
	}
}

int main(){
    .
    .
    .
    int q=0;
	rep(i,0,sz(tx)){
		while(g[q][tx[i]-a]==-1){
			q=f[q];
		}
		q=g[q][tx[i]-a];
		int aux=q;
		if(out[aux] or pattern[aux]){
			if(pattern[aux]) cout<<pat[inde[aux]]<<endl;
			while(out[aux]){
				cout<<pat[inde[out[aux]]]<<endl;
				aux=out[aux];
			}
		}
	}
    .
    .
    .
}
